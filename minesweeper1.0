#include<iostream>
#include<time.h>
#include<stdio.h>
#include<graphics.h>			//图形库：使用2017以前的VS或用easyX软件补充安装
#include<mmsystem.h>
#include<conio.h>
#pragma comment(lib,"winmm.lib")		//音频设备接口
using namespace std;
IMAGE image[13];		//存放图片
#define N 10  //格子数：待改，除此之外还有很多参数可以加入main函数中，以便编写另一模式
#define M 50  //图片大小
int map[N + 2][N + 2];			//存放地图状况  -1表示雷
int win = N * N - 15;
void StartWindow();		//开始界面
void gamebegin(int mine);       //开始游戏
void DrawGraph();		//画图
int MouseClick();	    //鼠标点击事件
void modelchoose();
void loadingPlay(int x, int y);	//运用递归实现点击一大片
int main() {
	initgraph(500, 500);
	StartWindow();
	closegraph();
}
void StartWindow() {
	mciSendString(L"open ./背景音乐.mp3 alias bgm", 0, 0, 0);//不知道为什么要7s之后才开始播放
	mciSendString(L"play bgm repeat", 0, 0, 0);
	loadimage(&image[11], L"./image/start.jpg", 500, 500);
	loadimage(&image[0], L"./image/blank.jpg", M, M);
	loadimage(&image[1], L"./image/1.jpg", M, M);
	loadimage(&image[2], L"./image/2.jpg", M, M);
	loadimage(&image[3], L"./image/3.jpg", M, M);
	loadimage(&image[4], L"./image/4.jpg", M, M);
	loadimage(&image[5], L"./image/5.jpg", M, M);
	loadimage(&image[6], L"./image/6.jpg", M, M);
	loadimage(&image[7], L"./image/7.jpg", M, M);
	loadimage(&image[8], L"./image/8.jpg", M, M);
	loadimage(&image[9], L"./image/mine.jpg", M, M);
	loadimage(&image[10], L"./image/tag.jpg", M, M);
	loadimage(&image[12], L"./image/0.jpg", M, M);
	putimage(0, 0, &image[11]);
	MOUSEMSG msg = { 0 };
	settextstyle(40, 20, L"楷体");
	while (1) {
		msg = GetMouseMsg();
		if (msg.x > 200 && msg.x < 280 && msg.y >330 && msg.y < 370) {
			settextcolor(RGB(255, 0, 0));
			outtextxy(200, 330, L"开始");
		}
		else if (msg.x > 200 && msg.x < 280 && msg.y >410 && msg.y < 450) {
			settextcolor(RGB(255, 0, 0));		//设置鼠标经过字体颜色
			outtextxy(200, 410, L"退出");
		}
		else {
			settextcolor(RGB(255, 255, 255));             //设置原字体颜色 
			outtextxy(200, 330, L"开始");
			outtextxy(200, 410, L"退出");
		}
		switch (msg.uMsg) {
		case WM_LBUTTONDOWN:
			if (msg.x > 200 && msg.x < 340 && msg.y >330 && msg.y < 370) {
				modelchoose();
				return;
			}
			else if (msg.x > 200 && msg.x < 340 && msg.y >410 && msg.y < 450) {
				exit(0);
			}
		}
	}
}
void modelchoose() {
	int Num_mine;
	Num_mine = 0;
	HWND hWnd = GetHWnd();
	srand((unsigned)time(NULL));
	if ((MessageBox(hWnd, L"请按下确定，然后由键盘输入模式\n(输入A进入15雷模式)\n(B进入20雷模式)\n(C进入50雷模式)", L"开始游戏", MB_OK) == IDOK))
		;
	while (1)
	{
		if (_kbhit()) {
			Num_mine = _getch() - 47;
			if (Num_mine == 1 || Num_mine == 50)
			{
				Num_mine = 15; gamebegin(Num_mine); break;
			}
			else if (Num_mine == 2 || Num_mine == 51)
			{
				Num_mine = 20; gamebegin(Num_mine); break;
			}
			else if (Num_mine == 3 || Num_mine == 52)
			{
				Num_mine = 30; gamebegin(Num_mine); break;
			}
			else
				;
		}
	}
}
void gamebegin(int mine) {
	while (1) {
		cleardevice();
		win = N * N - mine;
		int type = 0;
		HWND hWnd = GetHWnd();
		int x, y, flag = 0;
		srand((unsigned)time(NULL));
		for (int i = 0; i < N + 2; i++) {
			for (int j = 0; j < N + 2; j++) {
				map[i][j] = 0;
			}
		}
		while (flag < mine) {
			x = rand() % 10 + 1;
			y = rand() % 10 + 1;
			if (map[x][y] != -1) {
				map[x][y] = -1;
				flag++;
			}
		}
		for (int i = 1; i <= N; i++) {	//扫描数组10X10显示部分
			for (int j = 1; j <= N; j++) {
				if (map[i][j] != -1) {
					for (int m = i - 1; m <= i + 1; m++) {//扫描包含该数字的九个格子
						for (int n = j - 1; n <= j + 1; n++) {
							if (map[m][n] == -1) {
								map[i][j]++;
							}
						}
					}
				}
			}
		}
		while (1) {
			DrawGraph();
			type = MouseClick();
			if (type == -1) {
				DrawGraph();
				if (MessageBox(hWnd, L"按下确定重玩", L"游戏失败", MB_RETRYCANCEL) == IDRETRY)
					break;
				else
					exit(0);
			}
			if (win == 0) {
				DrawGraph();
				if (MessageBox(hWnd, L"按下确定重玩", L"胜利！", MB_RETRYCANCEL) == IDRETRY)
					break;
				else
					exit(0);
			}
		}
	}
}
void DrawGraph() {
	for (int i = 1; i <= N; i++) {
		for (int j = 1; j <= N; j++) {
			switch (map[i][j])
			{
			case 9:putimage((i - 1) * M, (j - 1) * M, &image[9]); break;
			case 10:putimage((i - 1) * M, (j - 1) * M, &image[0]); break;
			case 11:putimage((i - 1) * M, (j - 1) * M, &image[1]); break;
			case 12:putimage((i - 1) * M, (j - 1) * M, &image[2]); break;
			case 13:putimage((i - 1) * M, (j - 1) * M, &image[3]); break;
			case 14:putimage((i - 1) * M, (j - 1) * M, &image[4]); break;
			case 15:putimage((i - 1) * M, (j - 1) * M, &image[5]); break;
			case 16:putimage((i - 1) * M, (j - 1) * M, &image[6]); break;
			case 17:putimage((i - 1) * M, (j - 1) * M, &image[7]); break;
			case 18:putimage((i - 1) * M, (j - 1) * M, &image[8]); break;
			case 29:putimage((i - 1) * M, (j - 1) * M, &image[10]); break;
			case 30:putimage((i - 1) * M, (j - 1) * M, &image[10]); break;
			case 31:putimage((i - 1) * M, (j - 1) * M, &image[10]); break;
			case 32:putimage((i - 1) * M, (j - 1) * M, &image[10]); break;
			case 33:putimage((i - 1) * M, (j - 1) * M, &image[10]); break;
			case 34:putimage((i - 1) * M, (j - 1) * M, &image[10]); break;
			case 35:putimage((i - 1) * M, (j - 1) * M, &image[10]); break;
			case 36:putimage((i - 1) * M, (j - 1) * M, &image[10]); break;
			case 37:putimage((i - 1) * M, (j - 1) * M, &image[10]); break;
			case 38:putimage((i - 1) * M, (j - 1) * M, &image[10]); break;
			default:putimage((i - 1) * M, (j - 1) * M, &image[12]); break;
			}
		}
	}
}
int MouseClick() {
	MOUSEMSG msg = { 0 };
	while (1) {
		msg = GetMouseMsg();
		switch (msg.uMsg)
		{
		case WM_LBUTTONDOWN:
			if (map[msg.x / M + 1][msg.y / M + 1] == 0) {
				loadingPlay(msg.x / M + 1, msg.y / M + 1);
			}
			else if (map[msg.x / M + 1][msg.y / M + 1] <= 8) {
				map[msg.x / M + 1][msg.y / M + 1] += 10;
				win--;
			}
			if (map[msg.x / M + 1][msg.y / M + 1] == 9) {
				return -1;
			}
			break;
		case WM_RBUTTONDOWN:
			if (map[msg.x / M + 1][msg.y / M + 1] <= 8) {
				map[msg.x / M + 1][msg.y / M + 1] += 30;
			}
			else if (map[msg.x / M + 1][msg.y / M + 1] >= 29) {
				map[msg.x / M + 1][msg.y / M + 1] -= 30;
			}
			break;
		}
		return 0;
	}
}
void loadingPlay(int x, int y) {
	map[x][y] += 10;
	win--;
	for (int i = x - 1; i <= x + 1; i++) {
		for (int j = y - 1; j <= y + 1; j++) {
			if (i <= 0 || i >= 11 || j <= 0 || j >= 11)  continue; //防止越界
			if (map[i][j] <= 8) {
				if (map[i][j] == 0) {
					loadingPlay(i, j);
				}
				else if (map[i][j] != -1) {
					map[i][j] += 10;
					win--;
				}
			}
		}
	}
}
